"use strict";
// Copyright IBM Corp. 2019. All Rights Reserved.
// Node module: @loopback/context
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = require("@loopback/metadata");
const assert = require("assert");
const debugFactory = require("debug");
const binding_filter_1 = require("./binding-filter");
const binding_sorter_1 = require("./binding-sorter");
const context_1 = require("./context");
const keys_1 = require("./keys");
const value_promise_1 = require("./value-promise");
const debug = debugFactory('loopback:context:interceptor');
const getTargetName = metadata_1.DecoratorFactory.getTargetName;
/* eslint-enable @typescript-eslint/no-explicit-any */
/**
 * InvocationContext represents the context to invoke interceptors for a method.
 * The context can be used to access metadata about the invocation as well as
 * other dependencies.
 */
class InvocationContext extends context_1.Context {
    /**
     * Construct a new instance of `InvocationContext`
     * @param parent - Parent context, such as the RequestContext
     * @param target - Target class (for static methods) or prototype/object
     * (for instance methods)
     * @param methodName - Method name
     * @param args - An array of arguments
     */
    constructor(
    // Make `parent` public so that the interceptor can add bindings to
    // the request context, for example, tracing id
    parent, target, methodName, args) {
        super(parent);
        this.parent = parent;
        this.target = target;
        this.methodName = methodName;
        this.args = args;
    }
    /**
     * Discover all binding keys for global interceptors (tagged by
     * ContextTags.GLOBAL_INTERCEPTOR)
     */
    getGlobalInterceptorBindingKeys() {
        const bindings = this.find(binding_filter_1.filterByTag(keys_1.ContextTags.GLOBAL_INTERCEPTOR));
        this.sortGlobalInterceptorBindings(bindings);
        return bindings.map(b => b.key);
    }
    /**
     * Sort global interceptor bindings by `globalInterceptorGroup` tags
     * @param bindings - An array of global interceptor bindings
     */
    sortGlobalInterceptorBindings(bindings) {
        // Get predefined ordered groups for global interceptors
        const orderedGroups = this.getSync(keys_1.ContextBindings.GLOBAL_INTERCEPTOR_ORDERED_GROUPS, {
            optional: true,
        }) || [];
        return binding_sorter_1.sortBindingsByPhase(bindings, keys_1.ContextTags.GLOBAL_INTERCEPTOR_GROUP, orderedGroups);
    }
    /**
     * The target class, such as `OrderController`
     */
    get targetClass() {
        return typeof this.target === 'function'
            ? this.target
            : this.target.constructor;
    }
    /**
     * The target name, such as `OrderController.prototype.cancelOrder`
     */
    get targetName() {
        return metadata_1.DecoratorFactory.getTargetName(this.target, this.methodName);
    }
    /**
     * Description of the invocation
     */
    get description() {
        return `InvocationContext(${this.name}): ${this.targetName}`;
    }
    toString() {
        return this.description;
    }
    /**
     * Load all interceptors for the given invocation context. It adds
     * interceptors from possibly three sources:
     * 1. method level `@intercept`
     * 2. class level `@intercept`
     * 3. global interceptors discovered in the context
     */
    loadInterceptors() {
        let interceptors = metadata_1.MetadataInspector.getMethodMetadata(exports.INTERCEPT_METHOD_KEY, this.target, this.methodName) || [];
        const targetClass = typeof this.target === 'function' ? this.target : this.target.constructor;
        const classInterceptors = metadata_1.MetadataInspector.getClassMetadata(exports.INTERCEPT_CLASS_KEY, targetClass) ||
            [];
        // Inserting class level interceptors before method level ones
        interceptors = mergeInterceptors(classInterceptors, interceptors);
        const globalInterceptors = this.getGlobalInterceptorBindingKeys();
        // Inserting global interceptors
        interceptors = mergeInterceptors(globalInterceptors, interceptors);
        return interceptors;
    }
    /**
     * Assert the method exists on the target. An error will be thrown if otherwise.
     * @param context - Invocation context
     */
    assertMethodExists() {
        const targetWithMethods = this.target;
        if (typeof targetWithMethods[this.methodName] !== 'function') {
            const targetName = getTargetName(this.target, this.methodName);
            assert(false, `Method ${targetName} not found`);
        }
        return targetWithMethods;
    }
    /**
     * Invoke the target method with the given context
     * @param context - Invocation context
     */
    invokeTargetMethod() {
        const targetWithMethods = this.assertMethodExists();
        /* istanbul ignore if */
        if (debug.enabled) {
            debug('Invoking method %s', getTargetName(this.target, this.methodName), this.args);
        }
        // Invoke the target method
        const result = targetWithMethods[this.methodName](...this.args);
        /* istanbul ignore if */
        if (debug.enabled) {
            debug('Method invoked: %s', getTargetName(this.target, this.methodName), result);
        }
        return result;
    }
}
exports.InvocationContext = InvocationContext;
/**
 * The `BindingTemplate` function to configure a binding as a global interceptor
 * by tagging it with `ContextTags.INTERCEPTOR`
 * @param binding - Binding object
 */
function asGlobalInterceptor(group) {
    return binding => {
        binding.tag(keys_1.ContextTags.GLOBAL_INTERCEPTOR);
        if (group)
            binding.tag({ [keys_1.ContextTags.GLOBAL_INTERCEPTOR_GROUP]: group });
    };
}
exports.asGlobalInterceptor = asGlobalInterceptor;
/**
 * Metadata key for method-level interceptors
 */
exports.INTERCEPT_METHOD_KEY = metadata_1.MetadataAccessor.create('intercept:method');
/**
 * Adding interceptors from the spec to the front of existing ones. Duplicate
 * entries are eliminated from the spec side.
 *
 * For example:
 *
 * - [log] + [cache, log] => [cache, log]
 * - [log] + [log, cache] => [log, cache]
 * - [] + [cache, log] => [cache, log]
 * - [cache, log] + [] => [cache, log]
 * - [log] + [cache] => [log, cache]
 *
 * @param interceptorsFromSpec - Interceptors from `@intercept`
 * @param existingInterceptors - Interceptors already applied for the method
 */
function mergeInterceptors(interceptorsFromSpec, existingInterceptors) {
    const interceptorsToApply = new Set(interceptorsFromSpec);
    const appliedInterceptors = new Set(existingInterceptors);
    // Remove interceptors that already exist
    for (const i of interceptorsToApply) {
        if (appliedInterceptors.has(i)) {
            interceptorsToApply.delete(i);
        }
    }
    // Add existing interceptors after ones from the spec
    for (const i of appliedInterceptors) {
        interceptorsToApply.add(i);
    }
    return Array.from(interceptorsToApply);
}
exports.mergeInterceptors = mergeInterceptors;
/**
 * Metadata key for method-level interceptors
 */
exports.INTERCEPT_CLASS_KEY = metadata_1.MetadataAccessor.create('intercept:class');
/**
 * A factory to define `@intercept` for classes. It allows `@intercept` to be
 * used multiple times on the same class.
 */
class InterceptClassDecoratorFactory extends metadata_1.ClassDecoratorFactory {
    mergeWithOwn(ownMetadata, target) {
        ownMetadata = ownMetadata || [];
        return mergeInterceptors(this.spec, ownMetadata);
    }
}
/**
 * A factory to define `@intercept` for methods. It allows `@intercept` to be
 * used multiple times on the same method.
 */
class InterceptMethodDecoratorFactory extends metadata_1.MethodDecoratorFactory {
    mergeWithOwn(ownMetadata, target, methodName, methodDescriptor) {
        ownMetadata = ownMetadata || {};
        const interceptors = ownMetadata[methodName] || [];
        // Adding interceptors to the list
        ownMetadata[methodName] = mergeInterceptors(this.spec, interceptors);
        return ownMetadata;
    }
}
/**
 * Decorator function `@intercept` for classes/methods to apply interceptors. It
 * can be applied on a class and its public methods. Multiple occurrences of
 * `@intercept` are allowed on the same target class or method. The decorator
 * takes a list of `interceptor` functions or binding keys.
 *
 * @example
 * ```ts
 * @intercept(log, metrics)
 * class MyController {
 *   @intercept('caching-interceptor')
 *   @intercept('name-validation-interceptor')
 *   greet(name: string) {
 *     return `Hello, ${name}`;
 *   }
 * }
 * ```
 *
 * @param interceptorOrKeys - One or more interceptors or binding keys that are
 * resolved to be interceptors
 */
function intercept(...interceptorOrKeys) {
    return function interceptDecoratorForClassOrMethod(target, method, 
    // Use `any` to for `TypedPropertyDescriptor`
    // See https://github.com/strongloop/loopback-next/pull/2704
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    methodDescriptor) {
        if (method && methodDescriptor) {
            // Method
            return InterceptMethodDecoratorFactory.createDecorator(exports.INTERCEPT_METHOD_KEY, interceptorOrKeys)(target, method, methodDescriptor);
        }
        if (typeof target === 'function' && !method && !methodDescriptor) {
            // Class
            return InterceptClassDecoratorFactory.createDecorator(exports.INTERCEPT_CLASS_KEY, interceptorOrKeys)(target);
        }
        // Not on a class or method
        throw new Error('@intercept cannot be used on a property: ' +
            metadata_1.DecoratorFactory.getTargetName(target, method, methodDescriptor));
    };
}
exports.intercept = intercept;
/**
 * Invoke a method with the given context
 * @param context - Context object
 * @param target - Target class (for static methods) or object (for instance methods)
 * @param methodName - Method name
 * @param args - An array of argument values
 */
function invokeMethodWithInterceptors(context, target, methodName, args) {
    const invocationCtx = new InvocationContext(context, target, methodName, args);
    invocationCtx.assertMethodExists();
    return value_promise_1.tryWithFinally(() => {
        const interceptors = invocationCtx.loadInterceptors();
        return invokeInterceptors(invocationCtx, interceptors);
    }, () => invocationCtx.close());
}
exports.invokeMethodWithInterceptors = invokeMethodWithInterceptors;
/**
 * Invoke the interceptor chain
 * @param context - Context object
 * @param interceptors - An array of interceptors
 */
function invokeInterceptors(context, interceptors) {
    let index = 0;
    return next();
    /**
     * Invoke downstream interceptors or the target method
     */
    function next() {
        // No more interceptors
        if (index === interceptors.length) {
            return context.invokeTargetMethod();
        }
        return invokeNextInterceptor();
    }
    /**
     * Invoke downstream interceptors
     */
    function invokeNextInterceptor() {
        const interceptor = interceptors[index++];
        const interceptorFn = loadInterceptor(interceptor);
        return value_promise_1.transformValueOrPromise(interceptorFn, fn => {
            /* istanbul ignore if */
            if (debug.enabled) {
                debug('Invoking interceptor %d (%s) on %s', index - 1, fn.name, getTargetName(context.target, context.methodName), context.args);
            }
            return fn(context, next);
        });
    }
    /**
     * Return the interceptor function or resolve the interceptor function as a
     * binding from the context
     * @param interceptor - Interceptor function or binding key
     */
    function loadInterceptor(interceptor) {
        if (typeof interceptor === 'function')
            return interceptor;
        debug('Resolving interceptor binding %s', interceptor);
        return context.getValueOrPromise(interceptor);
    }
}
//# sourceMappingURL=interceptor.js.map