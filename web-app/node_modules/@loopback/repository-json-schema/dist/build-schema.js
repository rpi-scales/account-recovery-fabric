"use strict";
// Copyright IBM Corp. 2018,2019. All Rights Reserved.
// Node module: @loopback/repository-json-schema
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const repository_1 = require("@loopback/repository");
const keys_1 = require("./keys");
/**
 * Gets the JSON Schema of a TypeScript model/class by seeing if one exists
 * in a cache. If not, one is generated and then cached.
 * @param ctor - Contructor of class to get JSON Schema from
 */
function getJsonSchema(ctor, options) {
    // In the near future the metadata will be an object with
    // different titles as keys
    const cached = context_1.MetadataInspector.getClassMetadata(keys_1.JSON_SCHEMA_KEY, ctor);
    if (cached) {
        return cached;
    }
    else {
        const newSchema = modelToJsonSchema(ctor, options);
        context_1.MetadataInspector.defineMetadata(keys_1.JSON_SCHEMA_KEY.key, newSchema, ctor);
        return newSchema;
    }
}
exports.getJsonSchema = getJsonSchema;
/**
 * Describe the provided Model as a reference to a definition shared by multiple
 * endpoints. The definition is included in the returned schema.
 *
 * @example
 *
 * ```ts
 * const schema = {
 *   $ref: '/definitions/Product',
 *   definitions: {
 *     Product: {
 *       title: 'Product',
 *       properties: {
 *         // etc.
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param modelCtor - The model constructor (e.g. `Product`)
 * @param options - Additional options
 */
function getJsonSchemaRef(modelCtor, options) {
    const schemaWithDefinitions = getJsonSchema(modelCtor, options);
    const key = schemaWithDefinitions.title;
    // ctor is not a model
    if (!key)
        return schemaWithDefinitions;
    const definitions = Object.assign({}, schemaWithDefinitions.definitions);
    const schema = Object.assign({}, schemaWithDefinitions);
    delete schema.definitions;
    definitions[key] = schema;
    return {
        $ref: `#/definitions/${key}`,
        definitions,
    };
}
exports.getJsonSchemaRef = getJsonSchemaRef;
/**
 * Gets the wrapper function of primitives string, number, and boolean
 * @param type - Name of type
 */
function stringTypeToWrapper(type) {
    if (typeof type === 'function') {
        return type;
    }
    type = type.toLowerCase();
    let wrapper;
    switch (type) {
        case 'number': {
            wrapper = Number;
            break;
        }
        case 'string': {
            wrapper = String;
            break;
        }
        case 'boolean': {
            wrapper = Boolean;
            break;
        }
        case 'array': {
            wrapper = Array;
            break;
        }
        case 'object': {
            wrapper = Object;
            break;
        }
        case 'date': {
            wrapper = Date;
            break;
        }
        case 'buffer': {
            wrapper = Buffer;
            break;
        }
        default: {
            throw new Error('Unsupported type: ' + type);
        }
    }
    return wrapper;
}
exports.stringTypeToWrapper = stringTypeToWrapper;
/**
 * Determines whether a given string or constructor is array type or not
 * @param type - Type as string or wrapper
 */
function isArrayType(type) {
    return type === Array || type === 'array';
}
exports.isArrayType = isArrayType;
/**
 * Converts property metadata into a JSON property definition
 * @param meta
 */
function metaToJsonProperty(meta) {
    const propDef = {};
    let result;
    let propertyType = meta.type;
    if (isArrayType(propertyType) && meta.itemType) {
        if (Array.isArray(meta.itemType)) {
            throw new Error('itemType as an array is not supported');
        }
        result = { type: 'array', items: propDef };
        propertyType = meta.itemType;
    }
    else {
        result = propDef;
    }
    const wrappedType = stringTypeToWrapper(propertyType);
    const resolvedType = repository_1.resolveType(wrappedType);
    if (resolvedType === Date) {
        Object.assign(propDef, {
            type: 'string',
            format: 'date-time',
        });
    }
    else if (repository_1.isBuiltinType(resolvedType)) {
        Object.assign(propDef, {
            type: resolvedType.name.toLowerCase(),
        });
    }
    else {
        Object.assign(propDef, { $ref: `#/definitions/${resolvedType.name}` });
    }
    if (meta.description) {
        Object.assign(propDef, {
            description: meta.description,
        });
    }
    if (meta.jsonSchema) {
        Object.assign(propDef, meta.jsonSchema);
    }
    return result;
}
exports.metaToJsonProperty = metaToJsonProperty;
// NOTE(shimks) no metadata for: union, optional, nested array, any, enum,
// string literal, anonymous types, and inherited properties
/**
 * Converts a TypeScript class into a JSON Schema using TypeScript's
 * reflection API
 * @param ctor - Constructor of class to convert from
 */
function modelToJsonSchema(ctor, jsonSchemaOptions = {}) {
    const options = Object.assign({}, jsonSchemaOptions);
    options.visited = options.visited || {};
    const meta = repository_1.ModelMetadataHelper.getModelMetadata(ctor);
    // returns an empty object if metadata is an empty object
    if (!(meta instanceof repository_1.ModelDefinition)) {
        return {};
    }
    const title = meta.title || ctor.name;
    if (options.visited[title])
        return options.visited[title];
    const result = { title };
    options.visited[title] = result;
    if (meta.description) {
        result.description = meta.description;
    }
    for (const p in meta.properties) {
        if (!meta.properties[p].type) {
            continue;
        }
        result.properties = result.properties || {};
        result.properties[p] = result.properties[p] || {};
        const metaProperty = Object.assign({}, meta.properties[p]);
        // populating "properties" key
        result.properties[p] = metaToJsonProperty(metaProperty);
        // handling 'required' metadata
        if (metaProperty.required) {
            result.required = result.required || [];
            result.required.push(p);
        }
        // populating JSON Schema 'definitions'
        // shimks: ugly type casting; this should be replaced by logic to throw
        // error if itemType/type is not a string or a function
        const resolvedType = repository_1.resolveType(metaProperty.type);
        const referenceType = isArrayType(resolvedType)
            ? // shimks: ugly type casting; this should be replaced by logic to throw
                // error if itemType/type is not a string or a function
                repository_1.resolveType(metaProperty.itemType)
            : resolvedType;
        if (typeof referenceType !== 'function' || repository_1.isBuiltinType(referenceType)) {
            continue;
        }
        const propSchema = getJsonSchema(referenceType, options);
        includeReferencedSchema(referenceType.name, propSchema);
        function includeReferencedSchema(name, schema) {
            if (!schema || !Object.keys(schema).length)
                return;
            result.definitions = result.definitions || {};
            // promote nested definition to the top level
            if (schema.definitions) {
                for (const key in schema.definitions) {
                    if (key === title)
                        continue;
                    result.definitions[key] = schema.definitions[key];
                }
                delete schema.definitions;
            }
            result.definitions[name] = schema;
        }
    }
    return result;
}
exports.modelToJsonSchema = modelToJsonSchema;
//# sourceMappingURL=build-schema.js.map